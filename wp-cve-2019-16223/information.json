{"description":"","goal":"","solution":"","readme":"# Wordpress cve-2019-16223   \r\n## Vulnerability description  \r\n\r\nThe disclosed vulnerability allows a remote attacker to perform cross-site scripting (XSS) attacks.\r\n\r\nThe vulnerability exists due to insufficient sanitization of user-supplied data in the post previews by contributors functionality. A remote attacker can trick the victim to follow a specially crafted link and execute arbitrary HTML and script code in user's browser in context of vulnerable website.\r\n\r\nSuccessful exploitation of this vulnerability may allow a remote attacker to steal potentially sensitive information, change appearance of the web page, perform phishing and drive-by-download attacks.\r\n\r\n## How to use    \r\nSet in /etc/host  \r\n```  \r\n<dsp-ip> dsp.com   \r\n```   \r\nAnd navigate wordpress:  \r\n\r\nhttp://dsp.com:11080/wp-login.php \r\n\r\nContributor creds:  \r\n```   \r\ncontributor/contributor  \r\n``` \r\n## Proof of Concept   \r\nThe vulnerability is due to two condition: \r\n1. wp_kses_bad_protocol_once() has an issue with URL sanitization that can be passed and can lead to cross-site scripting vulnerability:   \r\n\r\nthe function sanitizes bad protocols, and applies a convertion of HTML entities to avoid bypass techniques; anyway, in vulnerable versions, it only checks for html entities after two points, as it is possible to \r\nobserve by the applied fix: \r\n\r\n```\r\nfunction wp_kses_bad_protocol_once( $string, $allowed_protocols, $count = 1 ) {\r\n+\t$string  = preg_replace( '/(&#0*58(?![;0-9])|&#x0*3a(?![;a-f0-9]))/i', '$1;', $string );   # APPLIED FIX AFTER VULNERABILITY DETECTION \r\n\t$string2 = preg_split( '/:|&#0*58;|&#x0*3a;/i', $string, 2 );\r\n\tif ( isset( $string2[1] ) && ! preg_match( '%/\\?%', $string2[0] ) ) {\r\n\r\n```\r\nThis allows an attacker to inject attack strings such as:    \r\n\r\n```\r\n<a href=\"javascript&#58alert(document.domain)\">Example Attack</a>\r\n```\r\nAnyway, Wordpress protects against this attack because it converts any type of html entities during the rendering of posts. In a particular case, during preview, it is possible to inject html entities in a URL. That is the second condition. \r\n\r\n\r\n2. During preview, get_the_content() function in post-template.php replaces URL encoded characters with a corresponding HTML entity: \r\n\r\n```\r\nfunction get_the_content( $more_link_text = null, $strip_teaser = false ) {\r\n\r\n    ...\r\n    if ( $preview ) // Preview fix for JavaScript bug with foreign languages.\r\n        $output =   preg_replace_callback( '/\\%u([0-9A-F]{4})/', '_convert_urlencoded_to_entities', $output );\r\n\r\n    return $output;\r\n}\r\n\r\nfunction _convert_urlencoded_to_entities( $match ) {\r\n    return '&#' . base_convert( $match[1], 16, 10 ) . ';';\r\n}\r\n\r\n\r\n\r\n```\r\nFor this reason, it is possible to send URL encoded strings that will be converted in HTML entities during preview. HTML entities can be crafted to bypass wp_ses_bad_protocol_once() function due to issue described in condition 1. \r\n\r\nProof Of Concept:  \r\n1. Create a new post\r\n2. Insert in code editor the following HTML PoC code:   \r\n\r\n<a href=\"javascript%u003Aalert(/XSS/)\">poc</a>\r\n\r\n3. Click on preview and click the \"poc\" link   \r\n\r\n\r\nSolution: \r\n\r\nUpgrade Wordpress to version >= 5.2.3","author":"dsp"}
